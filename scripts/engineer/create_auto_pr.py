#!/usr/bin/env python3
"""
Create Auto PR - L'Ingegnera Automatica
Crea PR automatiche per refactoring.

Input: lista file da modificare + descrizione
Output: URL della PR creata

v1.0.0 - 1 Gennaio 2026
"""

import argparse
import json
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import List, Optional

__version__ = "1.0.0"
__version_date__ = "2026-01-01"


class AutoPRCreator:
    """Creatore automatico di Pull Request"""

    def __init__(self, dry_run: bool = False):
        self.dry_run = dry_run
        self.git_root = self._get_git_root()
        self.base_branch = self._get_base_branch()

    def _get_git_root(self) -> Path:
        """Ottiene root del repository git"""
        try:
            result = subprocess.run(
                ['git', 'rev-parse', '--show-toplevel'],
                capture_output=True,
                text=True,
                check=True
            )
            return Path(result.stdout.strip())
        except subprocess.CalledProcessError:
            print("‚ùå Non sono in un repository git", file=sys.stderr)
            sys.exit(1)

    def _get_base_branch(self) -> str:
        """Determina branch di base (main o master)"""
        try:
            # Prova main
            subprocess.run(
                ['git', 'rev-parse', '--verify', 'main'],
                capture_output=True,
                check=True
            )
            return 'main'
        except subprocess.CalledProcessError:
            # Prova master
            try:
                subprocess.run(
                    ['git', 'rev-parse', '--verify', 'master'],
                    capture_output=True,
                    check=True
                )
                return 'master'
            except subprocess.CalledProcessError:
                print("‚ùå Branch main/master non trovato", file=sys.stderr)
                sys.exit(1)

    def _run_command(self, cmd: List[str], description: str) -> tuple[bool, str]:
        """Esegue comando shell"""
        if self.dry_run:
            print(f"[DRY-RUN] {description}")
            print(f"[DRY-RUN] Command: {' '.join(cmd)}")
            return True, ""

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                check=True
            )
            return True, result.stdout.strip()
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Errore: {description}", file=sys.stderr)
            print(f"   {e.stderr}", file=sys.stderr)
            return False, e.stderr

    def create_branch(self, branch_name: Optional[str] = None) -> str:
        """Crea nuovo branch per refactor"""
        if not branch_name:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            branch_name = f"refactor/auto-{timestamp}"

        print(f"üìå Creo branch: {branch_name}")

        # Verifica se siamo su branch pulito
        success, output = self._run_command(
            ['git', 'status', '--porcelain'],
            "Verifica git status"
        )

        if output and not self.dry_run:
            print("‚ö†Ô∏è  Working directory non pulito!")
            print("   Fai commit o stash prima di procedere.")
            sys.exit(1)

        # Crea branch
        success, _ = self._run_command(
            ['git', 'checkout', '-b', branch_name],
            f"Crea branch {branch_name}"
        )

        if not success and not self.dry_run:
            sys.exit(1)

        return branch_name

    def modify_files(self, files: List[str], modification_type: str) -> None:
        """Modifica i file (placeholder - da implementare logica specifica)"""
        print(f"üìù Modifico {len(files)} file ({modification_type})...")

        for file_path in files:
            path = self.git_root / file_path
            if not path.exists():
                print(f"‚ö†Ô∏è  File non trovato: {file_path}", file=sys.stderr)
                continue

            print(f"   - {file_path}")

            # Qui andrebbero le modifiche specifiche
            # Per ora solo placeholder
            if self.dry_run:
                print(f"[DRY-RUN] Modificherei: {file_path}")

        print("‚úÖ Modifiche completate!")

    def create_commit(self, message: str, files: List[str]) -> None:
        """Crea commit con le modifiche"""
        print(f"üíæ Creo commit...")

        # Add files
        for file_path in files:
            success, _ = self._run_command(
                ['git', 'add', file_path],
                f"Add {file_path}"
            )
            if not success and not self.dry_run:
                sys.exit(1)

        # Commit
        commit_message = f"{message}\n\nü§ñ Generated by CervellaSwarm Engineer"
        success, _ = self._run_command(
            ['git', 'commit', '-m', commit_message],
            "Commit changes"
        )

        if not success and not self.dry_run:
            sys.exit(1)

        print("‚úÖ Commit creato!")

    def push_branch(self, branch_name: str) -> None:
        """Pusha branch su remote"""
        print(f"üöÄ Push branch su remote...")

        success, _ = self._run_command(
            ['git', 'push', '-u', 'origin', branch_name],
            f"Push {branch_name}"
        )

        if not success and not self.dry_run:
            sys.exit(1)

        print("‚úÖ Branch pushato!")

    def create_pr(self, branch_name: str, title: str, body: str) -> str:
        """Crea Pull Request con GitHub CLI"""
        print(f"üìã Creo Pull Request...")

        # Verifica gh CLI disponibile
        success, _ = self._run_command(
            ['gh', '--version'],
            "Verifica gh CLI"
        )

        if not success and not self.dry_run:
            print("‚ùå GitHub CLI (gh) non installato!", file=sys.stderr)
            print("   Installa con: brew install gh", file=sys.stderr)
            sys.exit(1)

        # Crea PR
        pr_body = f"{body}\n\n---\n\nü§ñ Generated by CervellaSwarm Engineer v{__version__}"

        success, output = self._run_command(
            [
                'gh', 'pr', 'create',
                '--title', title,
                '--body', pr_body,
                '--base', self.base_branch
            ],
            "Crea PR"
        )

        if not success and not self.dry_run:
            sys.exit(1)

        # Estrae URL dalla output
        pr_url = output.strip() if output else "PR creata (dry-run)"

        print(f"‚úÖ PR creata: {pr_url}")
        return pr_url

    def run(
        self,
        files: List[str],
        title: str,
        description: str,
        modification_type: str = "refactor"
    ) -> str:
        """Esegue workflow completo"""
        print("="*60)
        print("üîß AUTO PR CREATOR - L'Ingegnera")
        print("="*60)

        if self.dry_run:
            print("‚ö†Ô∏è  DRY-RUN MODE - Nessuna modifica reale\n")

        # 1. Crea branch
        branch_name = self.create_branch()

        # 2. Modifica files
        self.modify_files(files, modification_type)

        # 3. Commit
        commit_message = f"refactor: {title}"
        self.create_commit(commit_message, files)

        # 4. Push
        self.push_branch(branch_name)

        # 5. Crea PR
        pr_url = self.create_pr(branch_name, title, description)

        print("\n" + "="*60)
        print("‚úÖ WORKFLOW COMPLETATO!")
        print("="*60)
        print(f"Branch: {branch_name}")
        print(f"PR URL: {pr_url}")
        print("="*60 + "\n")

        return pr_url


def main():
    """Entry point CLI"""
    parser = argparse.ArgumentParser(
        description="Create Auto PR - L'Ingegnera",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Esempi:
  # Crea PR per refactor di file specifici
  %(prog)s --files "src/app.py,src/utils.py" --title "Split app.py" --description "Refactor app.py in moduli"

  # Dry-run (no changes)
  %(prog)s --files "src/app.py" --title "Test" --description "Test PR" --dry-run

  # Da file JSON
  %(prog)s --from-json refactor-plan.json
        """
    )

    parser.add_argument(
        '--files',
        help='Lista file da modificare (comma-separated)',
        default=None
    )

    parser.add_argument(
        '--title',
        help='Titolo della PR',
        default=None
    )

    parser.add_argument(
        '--description',
        help='Descrizione della PR',
        default=None
    )

    parser.add_argument(
        '--modification-type',
        help='Tipo di modifica (refactor, split, merge)',
        default='refactor'
    )

    parser.add_argument(
        '--from-json',
        help='Leggi configurazione da file JSON',
        default=None
    )

    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Dry-run mode (no actual changes)'
    )

    parser.add_argument(
        '--version',
        action='version',
        version=f'%(prog)s {__version__} ({__version_date__})'
    )

    args = parser.parse_args()

    # Legge da JSON se specificato
    if args.from_json:
        json_path = Path(args.from_json)
        if not json_path.exists():
            print(f"‚ùå File JSON non trovato: {json_path}", file=sys.stderr)
            sys.exit(1)

        with open(json_path, 'r') as f:
            config = json.load(f)

        files = config.get('files', [])
        title = config.get('title', 'Auto Refactor')
        description = config.get('description', 'Automated refactoring')
        modification_type = config.get('modification_type', 'refactor')

    else:
        # Valida argomenti richiesti
        if not args.files or not args.title or not args.description:
            parser.error("--files, --title e --description sono obbligatori (o usa --from-json)")

        files = [f.strip() for f in args.files.split(',')]
        title = args.title
        description = args.description
        modification_type = args.modification_type

    # Crea PR
    creator = AutoPRCreator(dry_run=args.dry_run)
    pr_url = creator.run(
        files=files,
        title=title,
        description=description,
        modification_type=modification_type
    )

    # Output finale
    print(f"\nüéâ PR URL: {pr_url}")


if __name__ == '__main__':
    main()
